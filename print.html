<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gorse Document</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-recommend.html"><strong aria-hidden="true">1.2.</strong> Recommend using Gorse</a></li><li class="chapter-item expanded "><a href="ch01-03-config.html"><strong aria-hidden="true">1.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="ch01-04-demo.html"><strong aria-hidden="true">1.4.</strong> GitRec, The Live Demo</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Chapter 2: Build Recommender</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-feedback.html"><strong aria-hidden="true">2.1.</strong> Feedback Collection</a></li><li class="chapter-item expanded "><a href="ch02-02-strategy.html"><strong aria-hidden="true">2.2.</strong> Recommendation Strategy</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3: Monitoring</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-logging.html"><strong aria-hidden="true">3.1.</strong> Log Monitoring</a></li><li class="chapter-item expanded "><a href="ch03-02-metrics.html"><strong aria-hidden="true">3.2.</strong> Metrics Monitoring</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gorse Document</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-quick-start"><a class="header" href="#chapter-1-quick-start">Chapter 1: Quick Start</a></h1>
<p>Gorse is an open source recommendation system written in Go. Gorse aims to be an universal open source recommender system that can be easily introduced into a wide variety of online services. By importing items, users and interaction data into Gorse, the system will automatically train models to generate recommendations for each user. Project features are as follows.</p>
<ul>
<li><strong>AutoML</strong>: Choose the best recommendation model and stargety automatically by model searching in the background.</li>
<li><strong>Distributed Recommendation</strong>: Single node training, distributed prediction, and ability to achieve horizontal scaling in the recommendation stage.</li>
<li><strong>RESTful API</strong>: Provide RESTful APIs for data CRUD and recommendation requests.</li>
<li><strong>Dashboard</strong>: Provide dashboard for data import and export, monitoring, and cluster status checking.</li>
</ul>
<p>Gorse is a single node training and distributed prediction recommender system. Gorse stores data in MySQL or MongoDB, with intermediate data cached in Redis. The cluster consists of a master node, multiple worker nodes, and server nodes. The master node is responsible for model training, non-personalized item recommendation, configuration management, and membership management. The server node is responsible for exposing the RESTful APIs and online real-time recommendations. Worker nodes are responsible for offline recommendation for each user. In addition, administrator can perform system monitoring, data import and export, and system status checking via the dashboard on the master node.</p>
<center><img width=480 src="img/architecture.png"/></center>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Gorse can be setup via Docker Compose or maually.</p>
<h2 id="setup-gorse-with-docker-compose"><a class="header" href="#setup-gorse-with-docker-compose">Setup Gorse with Docker Compose</a></h2>
<p>The best practice to manage Gorse nodes is using orchestration tools such as Docker Compose, etc.. There are Docker images of the master node, the server node and the worker node.</p>
<table><thead><tr><th>Docker Image</th><th>Image Size</th></tr></thead><tbody>
<tr><td>gorse-master</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-master"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-master" alt="" /></a></td></tr>
<tr><td>gorse-server</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-server"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-server" alt="" /></a></td></tr>
<tr><td>gorse-worker</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-worker"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-worker" alt="" /></a></td></tr>
</tbody></table>
<p>There is an example <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/docker-compose.yml">docker-compose.yml</a> consists of a master node, a server node and a worker node, a Redis instance, and a MySQL instance.</p>
<ul>
<li>Create a configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">config.toml</a> (Docker Compose version) in the working directory.</li>
<li>Setup the Gorse cluster using Docker Compose.</li>
</ul>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import to the MySQL instance.</li>
</ul>
<pre><code>mysql -h 127.0.0.1 -u root -proot_pass gorse &lt; github.sql
</code></pre>
<ul>
<li>Restart the master node to apply imported data.</li>
</ul>
<pre><code class="language-bash">docker-compose restart
</code></pre>
<p>These images tagged with <code>latest</code> tag are built from the master branch. The <code>tag</code> should be fixed to a specified version in production.</p>
<h2 id="setup-gorse-manually"><a class="header" href="#setup-gorse-manually">Setup Gorse Manually</a></h2>
<p>Binary distributions have been provided for 64-bit Windows/Linux/Mac OS on the <a href="https://github.com/zhenghaoz/gorse/releases">release</a> page. Due to the demand on large memories, 64-bit machines are highly recommended to deploy Gorse.</p>
<p>Gorse depends on following softwares:</p>
<table><thead><tr><th>Software</th><th>Role</th></tr></thead><tbody>
<tr><td><em>Redis</em></td><td>used to store caches.</td></tr>
<tr><td><em>MySQL/MongoDB</em></td><td>used to store data.</td></tr>
</tbody></table>
<ul>
<li>Install Gorse</li>
</ul>
<p><strong>Option 1:</strong> Download binary distributions (Linux)</p>
<pre><code class="language-bash">wget https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_linux_amd64.zip
unzip gorse_linux_amd64.zip
</code></pre>
<p>For Windows and MacOS (Intel Chip or Apple Silicon), download <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_windows_amd64.zip">gorse_windows_amd64.zip</a>, <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_darwin_amd64.zip">gorse_darwin_amd64.zip</a> or <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_darwin_arm64.zip">gorse_darwin_arm64.zip</a> respectively.</p>
<p><strong>Option 2:</strong> Build executable files via <code>go get</code></p>
<pre><code class="language-bash">go get github.com/zhenghaoz/gorse/...
</code></pre>
<p>Built binaries locate at <code>$(go env GOPATH)/bin</code>.</p>
<ul>
<li>Configuration</li>
</ul>
<p>Create a configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template">config.toml</a> in the working directory. Set <code>cache_store</code> and <code>data_store</code> in the configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template">config.toml</a>. </p>
<pre><code class="language-toml"># This section declares settings for the database.
[database]

# database for caching (support Redis only)
cache_store = &quot;redis://localhost:6379&quot;

# database for persist data (support MySQL/MongoDB)
data_store = &quot;mysql://root@tcp(localhost:3306)/gorse?parseTime=true&quot;
</code></pre>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import to the MySQL instance.</li>
</ul>
<pre><code class="language-bash">mysql -h 127.0.0.1 -u root gorse &lt; github.sql
</code></pre>
<ul>
<li>Start the master node</li>
</ul>
<pre><code class="language-bash">./gorse-master -c config.toml
</code></pre>
<p><code>-c</code> specify the path of the configuration file.</p>
<ul>
<li>Start the server node and worker node</li>
</ul>
<pre><code class="language-bash">./gorse-server --master-host 127.0.0.1 --master-port 8086 \
    --http-host 127.0.0.1 --http-port 8087
</code></pre>
<p><code>--master-host</code> and <code>--master-port</code> are the RPC host and port of the master node. <code>--http-host</code> and <code>--http-port</code> are the HTTP host and port for RESTful APIs and metrics reporting of this server node.</p>
<pre><code class="language-bash">./gorse-worker --master-host 127.0.0.1 --master-port 8086 \
    --http-host 127.0.0.1 --http-port 8089 -j 4
</code></pre>
<p><code>--master-host</code> and <code>--master-port</code> are the RPC host and port of the master node. <code>--http-host</code> and <code>--http-port</code> are the HTTP host and port for metrics reporting of this worker node. <code>-j</code> is the number of working threads.</p>
<h2 id="play-with-gorse"><a class="header" href="#play-with-gorse">Play with Gorse:</a></h2>
<p>There are HTTP entries provided by Gorse:</p>
<table><thead><tr><th>Entry</th><th>Link</th></tr></thead><tbody>
<tr><td>Master Dashboard</td><td>http://127.0.0.1:8088/</td></tr>
<tr><td>Server RESTful API</td><td>http://127.0.0.1:8087/apidocs</td></tr>
<tr><td>Server Prometheus Metrics</td><td>http://127.0.0.1:8087/metrics</td></tr>
<tr><td>Worker Prometheus Metrics</td><td>http://127.0.0.1:8089/metrics</td></tr>
</tbody></table>
<h3 id="master-dashboard"><a class="header" href="#master-dashboard">Master Dashboard</a></h3>
<p><img src="img/dashboard.jpg" alt="" /></p>
<h3 id="server-restful-api"><a class="header" href="#server-restful-api">Server RESTful API</a></h3>
<p><img src="img/swagger.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommend-using-gorse"><a class="header" href="#recommend-using-gorse">Recommend using Gorse</a></h1>
<p>Each components and concepts of Gorse will be introduced in this section.</p>
<h2 id="users-items-and-feedback"><a class="header" href="#users-items-and-feedback">Users, Items and Feedback</a></h2>
<p>A recommender system is expected to recommend items to users. To learn the peference of each user, feedbacks between users and items are feed to recommender system. In Gorse, there are three types of entities.</p>
<ul>
<li><strong>User:</strong> A user is identified by a string identifier.</li>
</ul>
<pre><code class="language-go">type User struct {
	UserId    string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item is identified by a string identifier. A timestamp is used to record the freshness of this item. The timestamp could be last update time, release time, etc. Labels are used to describe characters of this item, eg., tags of a movie.</li>
</ul>
<pre><code class="language-go">type Item struct {
	ItemId    string
	Timestamp time.Time
	Labels    []string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback is identified a triple: feedback type, user ID and item ID. The type of feedback can be positive (like), negative (dislike) or neutural (read). The timestamp record the time that this feedback happened.</li>
</ul>
<pre><code class="language-go">type Feedback struct {
	FeedbackType string
	UserId       string
	ItemId       string
	Timestamp   time.Time
}
</code></pre>
<p>Types of feedbacks are classified to three categories: </p>
<ol>
<li><code>positive_feedback_types</code> mean a user favors a item. </li>
<li><code>click_feedback_types</code> mean a user favors a recommended item. This item must be recommended by Gorse.</li>
<li><code>read_feedback_type</code> means a user read a item. However, the real feedback this user has in his/her mind is never known.</li>
</ol>
<p>The difference between <code>positive_feedback_types</code> and <code>click_feedback_types</code> is that the item of <code>click_feedback_types</code> must come from recommendations of Gorse. The item of <code>positive_feedback_types</code> could be found by a user through other approaches such as search, direct access, etc. <code>read_feedback_type</code> is a neutral event. Negative feedback can be conduct by {<code>read_feedback_type</code> items} - {<code>positive_feedback_types</code> items}.</p>
<blockquote>
<p>There might be extra field in the defined structure. They are preserved for future usage.</p>
</blockquote>
<h2 id="workflow"><a class="header" href="#workflow">Workflow</a></h2>
<p>The main workflow of Gorse is as follows:</p>
<center><img width=480 src="img/workflow.png"/></center>
<ol>
<li>Feedbacks generated by users are collected to data store.</li>
<li>Archived feedbacks are pulled to train recommender model. There are two type of models (ranking model and CTR model) in Gorse, they are treated as one here.</li>
<li>Offline recommendations are generated in background from all items and cached.</li>
<li>Online recommendations are returned to users in real-time based on cached offline recommendations.</li>
</ol>
<h2 id="data-storage"><a class="header" href="#data-storage">Data Storage</a></h2>
<p>There are two types of storage used in Gorse: data store and cache store.</p>
<h3 id="data-store"><a class="header" href="#data-store">Data Store</a></h3>
<p>The <code>data_store</code> is used to store items, users, feedbacks and measurements. Currently, MySQL and MongoDB are supprted as data store. Other database will be avaiable once its interface is implemented. </p>
<p>Unfortunately, there are two challenges in data storage:</p>
<ol>
<li>
<p>What if a feedback with unknown user or item is inserted? There are two options <code>auto_insert_user</code> and <code>auto_insert_item</code> to control feedback insertion. If new users or items insertion is forbided, a feedback with new user or item will be ignored.</p>
</li>
<li>
<p>How to address stale feedback and items? Some items and its feedbacks are short-lived such as news. <code>positive_feedback_ttl</code> and <code>item_ttl</code> are used to ignore stale feedback and items when pulling dataset from data store.</p>
</li>
</ol>
<h3 id="cache-store"><a class="header" href="#cache-store">Cache Store</a></h3>
<p>The <code>cache_store</code> is used to store offline recommendation and temp variables. Only Redis is supported. Latest items, popular items, similar items and recommended items are cached in Redis. The length of each cached list is <code>cache_size</code>.</p>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Recommended items come from multiple sources through multiple stages. Non-personalized recommendations (popular/latest/similar) are generated by the master node. Offline personalized recommendations are generated by worker nodes while online personalized recommendations are generated by server nodes.</p>
<h3 id="popular-items"><a class="header" href="#popular-items">Popular Items</a></h3>
<p>Items with maximum number of users will are collected. To avoid popular items resist on the top list, <code>popular_window</code> restricts that timestamps of collected items must be after <code>popular_window</code> days ago. There will be no timestamp restriction if <code>popular_window</code> is <code>0</code>.</p>
<h3 id="latest-items"><a class="header" href="#latest-items">Latest Items</a></h3>
<p>Items with latest timestamps are collected. Items won't be added to latest items collection if their timestamp is empty.</p>
<h3 id="similar-items"><a class="header" href="#similar-items">Similar Items</a></h3>
<p>For each item, top n (n equals <code>cache_size</code>) similar items are collected. In current implementation, the similarity between items are the number of common users of two items<sup class="footnote-reference"><a href="#6">1</a></sup>.</p>
<h3 id="offline-recommendation"><a class="header" href="#offline-recommendation">Offline Recommendation</a></h3>
<p>Worker nodes collect top n items from all items and save them to cache. Besides, latest items are added to address the cold-start problem in recommender system. When labels of items exists, the CTR prediction model is enabled, vice versa. The procedure of offline recommendatin is different depend on whether the CTR model is enabled.</p>
<p><strong>If the CTR model is enabled:</strong></p>
<ol>
<li>Collect top <code>cache_size</code> items from unseen items of currrent user using ranking model.</li>
<li>Append <code>explore_latest_num</code> latest items to the collection.</li>
<li>Rerank collected items using the CTR prediction model.</li>
</ol>
<p><strong>If the CTR model is disabled:</strong></p>
<ol>
<li>Collect top <code>cache_size</code> items from unseen items of currrent user using ranking model.</li>
<li>Insert <code>explore_latest_num</code> latest items to random positions in the collection.</li>
</ol>
<p>Offline recommendation cache will be consumed by users and fashion will change. Offline recommendation will be refreshed under one of these two conditions:</p>
<ul>
<li>The timestamp of offline recommendation has been <code>refresh_recommend_period</code> days ago.</li>
<li>New feedbacks have been inserted since the timestamp of offline recommendation.</li>
</ul>
<p>There are 4 ranking models (BPR<sup class="footnote-reference"><a href="#5">2</a></sup>/ALS<sup class="footnote-reference"><a href="#3">3</a></sup>/CCD<sup class="footnote-reference"><a href="#4">4</a></sup>) and 1 CTR model (factorization machines<sup class="footnote-reference"><a href="#2">5</a></sup>) in Gorse. They will be applied automatically by model searcher. In ranking models, items and users are represented as embedding vectors. Since the dot product between two vectors is fast, ranking models are used to find top N items among all items. In CTR models, features from users or items are used in prediction. It's expensive to use CTR models to predict scores of all items.</p>
<h3 id="online-recommendation"><a class="header" href="#online-recommendation">Online Recommendation</a></h3>
<p>The online recommendation in the server node consists of three stages:</p>
<ol>
<li>Load offline recommendation from cache, remove read items.</li>
<li>If the number of offline recommendations is less than required, collect items similar to these items in the user's histrical feedbacks. Read items are removed as well.</li>
<li>If the number of recommendations is still less than required, collect items from <code>fallback_recommend</code> (latest items or popular items). Read items are removed.</li>
</ol>
<h2 id="model-update"><a class="header" href="#model-update">Model Update</a></h2>
<p>There are two kinds of models in Gorse, but the training and hyperparameters optimization procedures are quite the same. </p>
<h3 id="model-training"><a class="header" href="#model-training">Model Training</a></h3>
<p>Model training are done by the master node, as well as model search. The master node pull data from database and fit ranking model and CTR model periodically.</p>
<blockquote>
<ul>
<li>For every <code>fit_jobs</code> minutes:
<ul>
<li>Pull data from database.
<ul>
<li>Train model with hyperparameters found by model search using <code>fit_jobs</code> jobs.</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="model-search"><a class="header" href="#model-search">Model Search</a></h3>
<p>There are many hyperparameters for each recommendation model in Gorse. However, it is hard to configuare these hyperparameters manually even for machine learning experts. To help users get rid of hyperparameters tuning, Gorse integrates random search<sup class="footnote-reference"><a href="#1">6</a></sup> for hyperparameters optimization. The procedure of model search is as following:</p>
<blockquote>
<ul>
<li>For every <code>search_period</code> minutes:
<ul>
<li>Pull data from database.</li>
<li>For every recommender models:
<ul>
<li>For <code>search_trials</code> trials:
<ul>
<li>Sample a hyperparameter combination.</li>
<li>Train model with sampled hyperparameters by <code>search_epoch</code> epoches and <code>search_jobs</code> jobs.</li>
<li>Update best model.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="online-evaluation"><a class="header" href="#online-evaluation">Online Evaluation</a></h2>
<p>The only method to estimate recommendation performance is online evaluation. The metric of online evaluation in Gorse is click-through-rate: <code>click feedback</code> / <code>read feedback</code>.</p>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">1</sup>
<p>Zhang, Zhenghao, et al. &quot;SANS: Setwise Attentional Neural Similarity Method for Few-Shot Recommendation.&quot; DASFAA (3). 2021.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">2</sup>
<p>Rendle, Steffen, et al. &quot;BPR: Bayesian personalized ranking from implicit feedback.&quot; Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence. 2009.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Hu, Yifan, Yehuda Koren, and Chris Volinsky. &quot;Collaborative filtering for implicit feedback datasets.&quot; <em>2008 Eighth IEEE International Conference on Data Mining</em>. Ieee, 2008.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>He, Xiangnan, et al. &quot;Fast matrix factorization for online recommendation with implicit feedback.&quot; Proceedings of the 39th International ACM SIGIR conference on Research and Development in Information Retrieval. 2016.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">5</sup>
<p>Rendle, Steffen. &quot;Factorization machines.&quot; <em>2010 IEEE International Conference on Data Mining</em>. IEEE, 2010. </p>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">6</sup>
<p>Bergstra, James, and Yoshua Bengio. &quot;Random search for hyper-parameter optimization.&quot; Journal of machine learning research 13.2 (2012).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Previous section <em><a href="ch01-02-recommend.html">Recommend using Gorse</a></em> is helpful to understand configurations introduced in this section. These configuration items without default values must be filled. It's highly recommended to create new config file based on <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template"><code>config.toml.template</code></a>.</p>
<h2 id="database"><a class="header" href="#database"><code>[database]</code></a></h2>
<p>Configuratios under <code>[database]</code> are used to define behaviors on database and data.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data_store</code></td><td>string</td><td></td><td>Database for data store (supports MySQL/MongoDB)</td></tr>
<tr><td><code>cache_store</code></td><td>string</td><td></td><td>Database for cache store (supports Redis)</td></tr>
<tr><td><code>auto_insert_user</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new users when inserting new feedback</td></tr>
<tr><td><code>auto_insert_item</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new items when inserting new feedback</td></tr>
<tr><td><code>cache_size</code></td><td>string</td><td><code>100</code></td><td>Number of cached elements in cache store</td></tr>
<tr><td><code>positive_feedback_types</code></td><td>string</td><td></td><td>Types of positive feedback</td></tr>
<tr><td><code>click_feedback_types</code></td><td>string</td><td></td><td>Types of feedback for click events</td></tr>
<tr><td><code>read_feedback_type</code></td><td>string</td><td></td><td>Type of feedback for read events</td></tr>
<tr><td><code>positive_feedback_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of positive feedback</td></tr>
<tr><td><code>item_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of items</td></tr>
</tbody></table>
<p>The DSN (Database Source Name) format of the <code>data_store</code> and <code>cache_store</code> is as follows.</p>
<ul>
<li>Redis: <code>redis://hostname:port</code></li>
<li>MySQL: <code>mysql://[username[:password]@][protocol[(hostname:port)]]/database[?config1=value1&amp;...configN=valueN]</code></li>
<li>MongoDB: <code>mongodb://[username:password@]hostname1[:port1][,... hostnameN[:portN]]][/[database][?options]]</code></li>
</ul>
<h2 id="master"><a class="header" href="#master"><code>[master]</code></a></h2>
<p>Configuratios under <code>[master]</code> are used to define behaviors of the master node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td><code>127.0.0.1</code></td><td>Master node listening host for gRPC service (metadata exchange)</td></tr>
<tr><td><code>port</code></td><td>integer</td><td><code>8086</code></td><td>Master node listening port for gRPC service (metadata exchange)</td></tr>
<tr><td><code>http_host</code></td><td>string</td><td><code>127.0.0.1</code></td><td>Master node listening host for HTTP service (dashboard)</td></tr>
<tr><td><code>http_port</code></td><td>integer</td><td><code>8088</code></td><td>Master node listening port for HTTP service (dashboard)</td></tr>
<tr><td><code>fit_jobs</code></td><td>integer</td><td><code>1</code></td><td>Number of working threads for model training</td></tr>
<tr><td><code>search_jobs</code></td><td>integer</td><td><code>1</code></td><td>Number of working threads for model search</td></tr>
<tr><td><code>meta_timeout</code></td><td>integer</td><td><code>60</code></td><td>Metadata timeout in seconds</td></tr>
</tbody></table>
<h2 id="server"><a class="header" href="#server"><code>[server]</code></a></h2>
<p>Configuratios under <code>[server]</code> are used to define behaviors of the server node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default_n</code></td><td>integer</td><td><code>10</code></td><td>Default number of returned items</td></tr>
<tr><td><code>api_key</code></td><td>string</td><td></td><td>Secret key for RESTful APIs (SSL required)</td></tr>
</tbody></table>
<h2 id="recommend"><a class="header" href="#recommend"><code>[recommend]</code></a></h2>
<p>Configuratios under <code>[recommend]</code> are used to define behaviors of recommendation.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>popular_window</code></td><td>integer</td><td><code>180</code></td><td>Time window of popular items in days</td></tr>
<tr><td><code>fit_period</code></td><td>integer</td><td><code>60</code></td><td>Period of model trainig in minutes</td></tr>
<tr><td><code>search_period</code></td><td>integer</td><td><code>180</code></td><td>Period of model search in minutes</td></tr>
<tr><td><code>search_epoch</code></td><td>integer</td><td><code>100</code></td><td>Number of training epoches for each model in model search</td></tr>
<tr><td><code>search_trials</code></td><td>integer</td><td><code>10</code></td><td>Number of trials for each model in model search</td></tr>
<tr><td><code>refresh_recommend_period</code></td><td>integer</td><td><code>5</code></td><td>Period to refresh offline recommendation cache in days</td></tr>
<tr><td><code>fallback_recommend</code></td><td>integer</td><td><code>latest</code></td><td>Source of recommendation when personalized recommendation exhausted</td></tr>
<tr><td><code>explore_latest_num</code></td><td>integer</td><td><code>10</code></td><td>Number of latest items add to offline recommendation to address cold-start problem</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitrec-the-live-demo"><a class="header" href="#gitrec-the-live-demo">GitRec, The Live Demo</a></h1>
<p><a href="https://gitrec.gorse.io/">GitRec</a>, the live demo, is developed to demonstrate the usage of Gorse recommender system engine. A user logins in via GitHub OAuth, then repositories starred by this user before are imported to Gorse. Gorse recommends repositories to this user based on starred repositories. When this user saw a recommended repository, he or she can press ❤️ to tell GitRec that he or she like this recommendationn and press ⏯️ to skip current recommendationn.</p>
<p><img src="img/gitrec.jpg" alt="" /></p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<center><img width="500" src="img/gitrec-architecture.png"/></center>
<ul>
<li><strong>Import new repositories</strong>: The trending crawler crawls trending repositories and insert them into Gorse as new items. Since there are huge nuumber of repositories in GitHub, it's impossible add all of them into GitRec. So, only trending repositories are imported.</li>
<li><strong>Import user starred repositories</strong>: The user starred crawler crawls user starred repositories and insert them into Gorse as new fewdback typed <code>star</code> when a new user signed in.</li>
<li><strong>Recommendation and feedbacks</strong>: GitRec web service pulls recommendations from Gorse and show to users. When a user press ❤️, a feedback typed <code>like</code> will be inserted to Gorse. When ⏯️ pressed, a feedback typed <code>view</code> will be inserted to Gorse.</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>In GitRec, there are three types of feedbacks: <code>read</code>, <code>star</code> and <code>like</code>. <code>read</code> is the feedback type for read events (a user skip a recommended repository). <code>like</code> is the feedback type for user press ❤️. <code>star</code> is the feedback type for user starred repositories. Since <code>star</code> events doesn't happen in GitRec, it won't be added to <code>click_feedback_types</code>. </p>
<pre><code class="language-toml"># feedback type for positive event
positive_feedback_types = [&quot;star&quot;,&quot;like&quot;]

# feedback type for click event
click_feedback_types = [&quot;like&quot;]

# feedback type for read event
read_feedback_type = &quot;read&quot;
</code></pre>
<p>Other settings are the same as <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">docker/config.toml</a>.</p>
<h2 id="implemenetation"><a class="header" href="#implemenetation">Implemenetation</a></h2>
<p>This project consists of frontend, backend and crawlers. In this section, only these codes interact with Gorse are introduced. Other codes are avaliable in the <a href="https://github.com/zhenghaoz/gitrec">GitRec repository</a>.</p>
<ol>
<li>First thing is to wrap Gorse API as a python module. It sends HTTP requests and handle responses using <code>requests</code>.</li>
</ol>
<pre><code class="language-python">from collections import namedtuple
from datetime import datetime
from typing import List

import requests

Success = namedtuple(&quot;Success&quot;, [&quot;RowAffected&quot;])


class GorseException(BaseException):
    def __init__(self, status_code: int, message: str):
        self.status_code = status_code
        self.message = message


class Gorse:
    def __init__(self, entry_point):
        self.entry_point = entry_point

    def insert_feedback(
        self, feedback_type: str, user_id: str, item_id: str
    ) -&gt; Success:
        r = requests.post(
            self.entry_point + &quot;/api/feedback&quot;,
            json=[
                {
                    &quot;FeedbackType&quot;: feedback_type,
                    &quot;UserId&quot;: user_id,
                    &quot;ItemId&quot;: item_id,
                    &quot;Timestamp&quot;: datetime.now().isoformat(),
                }
            ],
        )
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def get_recommend(self, user_id: str, n: int = 1) -&gt; List[str]:
        r = requests.get(self.entry_point + &quot;/api/recommend/%s?n=%d&quot; % (user_id, n))
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_feedbacks(self, feedbacks) -&gt; Success:
        r = requests.post(self.entry_point + &quot;/api/feedback&quot;, json=feedbacks)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_item(self, item) -&gt; List[str]:
        r = requests.post(self.entry_point + &quot;/api/item&quot;, json=item)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)
</code></pre>
<ol start="2">
<li>In the code of trending crawler, insert trending repositories as new items.</li>
</ol>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    trending_repos = get_trending()
    for trending_repo in trending_repos:
        gorse_client.insert_item(get_repo_info(trending_repo))
</code></pre>
<ol start="3">
<li>In the code of starred repositories crawler, insert user starred repositories as <code>star</code> feedbacks.</li>
</ol>
<pre><code class="language-python">@app.task
def pull(token: str):
    g = GraphQLGitHub(token)
    stars = g.get_viewer_starred()
    gorse_client.insert_feedbacks(stars)
</code></pre>
<ol start="4">
<li>In the code of web service backend, pull recommendations from Gorse, insert <code>like</code> and <code>read</code> into Gorse.</li>
</ol>
<pre><code class="language-python">@app.route(&quot;/api/repo&quot;)
def get_repo():
    repo_id = gorse_client.get_recommend(session[&quot;user_id&quot;])[0]
    full_name = repo_id.replace(&quot;:&quot;, &quot;/&quot;)
    github_client = Github(github.token[&quot;access_token&quot;])
    repo = github_client.get_repo(full_name)
    # ...


@app.route(&quot;/api/like/&lt;repo_name&gt;&quot;)
def like_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;like&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)


@app.route(&quot;/api/read/&lt;repo_name&gt;&quot;)
def read_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;read&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-recommender"><a class="header" href="#build-recommender">Build Recommender</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback-collection"><a class="header" href="#feedback-collection">Feedback Collection</a></h1>
<p>In a recommender system, data is the foundation of all recommendation results, and this section will briefly introduce how to collect user data for Gorse recommender system. The recommender system relies on the feedback between users and items as training data, and the quality of training data determines the quality of recommendations.</p>
<h2 id="users-items-and-feedback-1"><a class="header" href="#users-items-and-feedback-1">Users, Items and Feedback</a></h2>
<p>Recommender system is complex, but to maximize reusability, Gorse has abstracted the data used in a recommender system as a collection of three entities: users, items, and feedback.</p>
<ul>
<li><strong>User:</strong> A user entity consists of a user ID and tags describing the user. The user tags can be empty, but these tags helps to improve the recommendation accuracy of the recommender system.</li>
</ul>
<pre><code class="language-go">type User struct {
    UserId    string
    Labels    []string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item entity consists of an item ID, an item timestamp and labels describing the item. The timestamp and labels can be empty, and the similarly based on labels information helps to improve the recommendation accuracy of the recommender system, while the timestamp is used to estimate the freshness of the item.</li>
</ul>
<pre><code class="language-go">type Item struct {
    ItemId    string
    Timestamp time.Time
    Labels    []string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback entity consists of user ID, item ID, feedback type and feedback timestamp, where the triad of user ID, item ID and feedback type is required to be unique in the database.</li>
</ul>
<p>Feedback represent events happened between users and items, which can be positive or negative. For example, sharing and liking are the user's positive feedback to a item. If the user does not have further positive feedback after reading, the user's feedback to the item is considered negative. If the user views the item, a read feedback will be recorded. Then, if the user gives positive feedback to the item, the read feedback will be overwritten by the positive feedback. Conversely, if the user does not give positive feedback, then the read feedback is considered as negative feedback.</p>
<pre><code class="language-go">type Feedback struct {
    FeedbackType string
    UserId       string
    ItemId       string
    Timestamp    time.Time
}
</code></pre>
<p>Gorse's server node provides RESTful APIs for inserting users, items and feedback, as well as getting recommendation for users. Please refer to the RESTful API documentation for a detailed description.</p>
<table><thead><tr><th>METHOD</th><th>URL</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>POST</td><td>/api/item</td><td>Insert item.</td></tr>
<tr><td>POST</td><td>/api/user</td><td>Insert user.</td></tr>
<tr><td>POST</td><td>/api/feedback</td><td>Insert feedback if the feedback not exist.</td></tr>
<tr><td>PUT</td><td>/api/feedback</td><td>Insert feedback, and overwrites existed feedback.</td></tr>
</tbody></table>
<h2 id="define-positive-feedback-and-read-feedback"><a class="header" href="#define-positive-feedback-and-read-feedback">Define Positive Feedback and Read Feedback</a></h2>
<p>Before inserting feedback to the Gorse recommender system, it is necessary to define which of the user's behaviors are positive feedback and which are read feedback. Read feedback is relatively easy to define, as it can be recorded as read feedback when a user has seen the recommended item. However, the definition of positive feedback depends more on the specific scenario. For TikTok, users can be considered as positive feedback if they “like” or “share” the current video; for YouTube, users can be considered as positive feedback if they watch the video to a certain proportion of completion, “like“ the video, or &quot;share&quot; the video. To summarize, positive feedback and read feedback are defined by the following rules.</p>
<ul>
<li><strong>Read Feedback:</strong> The user sees the item.</li>
<li><strong>Positive feedback:</strong> The user action that is expected to do by the service provider.</li>
</ul>
<p>For example, if Gabe Newell wants to build a recommender system for Steam based on Gorse, clicking into the game introduction page could be treated as read feedback (the game list page has too little information to determine that the user has read it), and then actions such as adding a wish list and adding a shopping cart are treated as positive feedback. Finally, set them in the configuration file as follows.</p>
<pre><code class="language-toml"># Add to wishlist or cart
positive_feedback_types = [&quot;wish_list&quot;, &quot;cart&quot;]

# Read the game introduction page
read_feedback_types = [&quot;read&quot;]
</code></pre>
<h2 id="insert-positive-feedback"><a class="header" href="#insert-positive-feedback">Insert Positive Feedback</a></h2>
<p>For positive feedback, it can be inserted when the user performs the action, where the timestamp is the current timestamp.</p>
<pre><code class="language-bash">curl -X POST &quot;http://127.0.0.1:8088/api/feedback&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d '[ { &quot;FeedbackType&quot;: &quot;read&quot;, &quot;ItemId&quot;: &quot;10086&quot;, &quot;Timestamp&quot;: &quot;2021-10-24T06:42:20.207Z&quot;, &quot;UserId&quot;: &quot;jack&quot; }]'
</code></pre>
<h2 id="insert-read-feedback"><a class="header" href="#insert-read-feedback">Insert Read Feedback</a></h2>
<p>For read feedback, the timestamp can be used to set the timeout of the recommendation results, in addition to recording the read time.</p>
<h3 id="proactive-insertion"><a class="header" href="#proactive-insertion">Proactive Insertion</a></h3>
<p>Positive feedback can be inserted into the recommender system when the user takes the action, while read feedback requires the application to detect the user's &quot;read&quot; behavior. The methods for displaying recommendations vary by application, but can be generally grouped into two categories.</p>
<ul>
<li><strong>Full screen mode:</strong> The most typical application is TikTok, where the user is considered &quot;read&quot; when the full screen content is shown to them. That is, the application can write a &quot;read&quot; feedback to the recommender system when the recommended content is shown to the user, and the read content will no longer be shown to the user.</li>
</ul>
<img src="/img/ch2/tiktok.jpg" width="300">
<img src="/img/ch2/youtube.jpg" width="300">
<ul>
<li><strong>List mode:</strong> The most typical application is YouTube, where the user is not considered &quot;read&quot; after looking at multiple videos in the list. When there are more than one videos, the user's attention is not able to browse the whole list. Moreover, if the read content is quickly discarded in the list mode, the recommended content is consumed too fast. Therefore, the best solution is to write a read feedback with a future timestamp to the recommender system when the item is presented to the user in the stream, and the read feedback will take effect when the time has reached the timestamp, and the read content will no longer be presented to the user.</li>
</ul>
<h3 id="automatic-insertion"><a class="header" href="#automatic-insertion">Automatic Insertion</a></h3>
<p>Proactively inserting read feedback to the recommender system requires the application to be able to accurately capture user browsing behavior. This task is easier for mobile applications, but more difficult for web applications. To address this problem, Gorse's API for getting recommendation results provides two parameters: <code>write−back−type</code> and <code>write−back−delay</code>.</p>
<ul>
<li><strong>In full screen mode:</strong> Get a recommendation and write a &quot;read&quot; feedback, the recommendation will not appear again afterwards.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;n=1&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<ul>
<li><strong>In list mode:</strong> Get 10 recommendations and write &quot;read&quot; feedback with timestamps of 10 minutes later. The 10 recommendations will not be discarded until after 10 minutes.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;write-back-delay=10&amp;n=10&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<p>The <code>write−back−type</code> and <code>write−back−delay</code> parameters of the recommendation API provide a convenient way to insert read feedback, but of course if you want the read feedback to be more accurate, it should be written to the recommender system by the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommendation-strategy"><a class="header" href="#recommendation-strategy">Recommendation Strategy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-monitoring"><a class="header" href="#chapter-3-monitoring">Chapter 3: Monitoring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log-monitoring"><a class="header" href="#log-monitoring">Log Monitoring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-monitoring"><a class="header" href="#metrics-monitoring">Metrics Monitoring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>These frequent asked questions are collected from issues, emails and chats. Feel free to ask more questions via <a href="https://github.com/zhenghaoz/gorse/issues">issue</a>, <a href="support@gorse.io">email</a>, <a href="https://discord.com/channels/830635934210588743/">Discord</a> (for English) or <a href="https://qm.qq.com/cgi-bin/qm/qr?k=lOERnxfAM2U2rj4C9Htv9T68SLIXg6uk&amp;jump_from=webapi">QQ</a> (for Chinese).</p>
<h2 id="technical-questions"><a class="header" href="#technical-questions">Technical Questions</a></h2>
<h3 id="1-how-to-address-the-cold-start-problem"><a class="header" href="#1-how-to-address-the-cold-start-problem">1. How to address the cold-start problem?</a></h3>
<p>Use <code>explore_latest_num</code> to inject latest items into recommendation. Also, item labels are helpful to rank new items in recommendation. For example:</p>
<pre><code class="language-toml">explore_latest_num = 10
</code></pre>
<p>It means 10 latest items are inserted to recommended items list.</p>
<h3 id="2-how-to-keep-track-of-items-recommended-to-each-user"><a class="header" href="#2-how-to-keep-track-of-items-recommended-to-each-user">2. How to keep track of items recommended to each user?</a></h3>
<p>There are two options:</p>
<ol>
<li>Insert a read type feedback to Gorse when a item is showed to a user. This is the way the official demo <a href="https://github.com/zhenghaoz/gitrec">zhenghaoz/gitrec</a> tracks user seen recommendations.</li>
<li>Use <code>write-back</code> parameter to write back recommendations as read feedbacks to Gorse, eg:</li>
</ol>
<pre><code class="language-bash">curl -i -H &quot;Accept: application/json&quot; -X GET http://127.0.0.1:8088//api/recommend/0?write-back=read
</code></pre>
<p>The 1st option is more accurate since it is done by front end but the 2rd option is more convenient.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
