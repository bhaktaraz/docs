<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gorse Document</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-recommend.html"><strong aria-hidden="true">1.2.</strong> Recommend using Gorse</a></li><li class="chapter-item expanded "><a href="ch01-03-config.html"><strong aria-hidden="true">1.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="ch01-04-demo.html"><strong aria-hidden="true">1.4.</strong> GitRec, The Live Demo</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Chapter 2: Build Recommender</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-feedback.html"><strong aria-hidden="true">2.1.</strong> Feedback Collection</a></li><li class="chapter-item expanded "><a href="ch02-02-strategy.html"><strong aria-hidden="true">2.2.</strong> Recommendation Strategy</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3: Monitoring</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-logging.html"><strong aria-hidden="true">3.1.</strong> Log Monitoring</a></li><li class="chapter-item expanded "><a href="ch03-02-metrics.html"><strong aria-hidden="true">3.2.</strong> Metrics Monitoring</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html">FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gorse Document</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-quick-start"><a class="header" href="#chapter-1-quick-start">Chapter 1: Quick Start</a></h1>
<p>Gorse is an open source recommendation system written in Go. Gorse aims to be an universal open source recommender system that can be easily introduced into a wide variety of online services. By importing items, users and interaction data into Gorse, the system will automatically train models to generate recommendations for each user. Project features are as follows.</p>
<ul>
<li><strong>AutoML</strong>: Choose the best recommendation model and stargety automatically by model searching in the background.</li>
<li><strong>Distributed Recommendation</strong>: Single node training, distributed prediction, and ability to achieve horizontal scaling in the recommendation stage.</li>
<li><strong>RESTful API</strong>: Provide RESTful APIs for data CRUD and recommendation requests.</li>
<li><strong>Dashboard</strong>: Provide dashboard for data import and export, monitoring, and cluster status checking.</li>
</ul>
<p>Gorse is a single node training and distributed prediction recommender system. Gorse stores data in MySQL or MongoDB, with intermediate data cached in Redis. The cluster consists of a master node, multiple worker nodes, and server nodes. The master node is responsible for model training, non-personalized item recommendation, configuration management, and membership management. The server node is responsible for exposing the RESTful APIs and online real-time recommendations. Worker nodes are responsible for offline recommendation for each user. In addition, administrator can perform system monitoring, data import and export, and system status checking via the dashboard on the master node.</p>
<center><img width=480 src="img/architecture.png"/></center>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Gorse can be setup via Docker Compose or maually.</p>
<h2 id="setup-gorse-with-docker-compose"><a class="header" href="#setup-gorse-with-docker-compose">Setup Gorse with Docker Compose</a></h2>
<p>The best practice to manage Gorse nodes is using orchestration tools such as Docker Compose, etc.. There are Docker images of the master node, the server node and the worker node.</p>
<table><thead><tr><th>Docker Image</th><th>Image Size</th></tr></thead><tbody>
<tr><td>gorse-master</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-master"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-master" alt="" /></a></td></tr>
<tr><td>gorse-server</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-server"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-server" alt="" /></a></td></tr>
<tr><td>gorse-worker</td><td><a href="https://hub.docker.com/repository/docker/zhenghaoz/gorse-worker"><img src="https://img.shields.io/docker/image-size/zhenghaoz/gorse-worker" alt="" /></a></td></tr>
</tbody></table>
<p>There is an example <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/docker-compose.yml">docker-compose.yml</a> consists of a master node, a server node and a worker node, a Redis instance, and a MySQL instance.</p>
<ul>
<li>Create a configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">config.toml</a> (Docker Compose version) in the working directory.</li>
<li>Setup the Gorse cluster using Docker Compose.</li>
</ul>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import to the MySQL instance.</li>
</ul>
<pre><code>mysql -h 127.0.0.1 -u root -proot_pass gorse &lt; github.sql
</code></pre>
<ul>
<li>Restart the master node to apply imported data.</li>
</ul>
<pre><code class="language-bash">docker-compose restart
</code></pre>
<p>These images tagged with <code>latest</code> tag are built from the master branch. The <code>tag</code> should be fixed to a specified version in production.</p>
<h2 id="setup-gorse-manually"><a class="header" href="#setup-gorse-manually">Setup Gorse Manually</a></h2>
<p>Binary distributions have been provided for 64-bit Windows/Linux/Mac OS on the <a href="https://github.com/zhenghaoz/gorse/releases">release</a> page. Due to the demand on large memories, 64-bit machines are highly recommended to deploy Gorse.</p>
<p>Gorse depends on following softwares:</p>
<table><thead><tr><th>Software</th><th>Role</th></tr></thead><tbody>
<tr><td><em>Redis</em></td><td>used to store caches.</td></tr>
<tr><td><em>MySQL/MongoDB</em></td><td>used to store data.</td></tr>
</tbody></table>
<ul>
<li>Install Gorse</li>
</ul>
<p><strong>Option 1:</strong> Download binary distributions (Linux)</p>
<pre><code class="language-bash">wget https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_linux_amd64.zip
unzip gorse_linux_amd64.zip
</code></pre>
<p>For Windows and MacOS (Intel Chip or Apple Silicon), download <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_windows_amd64.zip">gorse_windows_amd64.zip</a>, <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_darwin_amd64.zip">gorse_darwin_amd64.zip</a> or <a href="https://github.com/zhenghaoz/gorse/releases/latest/download/gorse_darwin_arm64.zip">gorse_darwin_arm64.zip</a> respectively.</p>
<p><strong>Option 2:</strong> Build executable files via <code>go get</code></p>
<pre><code class="language-bash">go get github.com/zhenghaoz/gorse/...
</code></pre>
<p>Built binaries locate at <code>$(go env GOPATH)/bin</code>.</p>
<ul>
<li>Configuration</li>
</ul>
<p>Create a configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template">config.toml</a> in the working directory. Set <code>cache_store</code> and <code>data_store</code> in the configuration file <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template">config.toml</a>. </p>
<pre><code class="language-toml"># This section declares settings for the database.
[database]

# database for caching (support Redis only)
cache_store = &quot;redis://localhost:6379&quot;

# database for persist data (support MySQL/MongoDB)
data_store = &quot;mysql://root@tcp(localhost:3306)/gorse?parseTime=true&quot;
</code></pre>
<ul>
<li>Download the SQL file <a href="https://cdn.gorse.io/example/github.sql">github.sql</a> and import to the MySQL instance.</li>
</ul>
<pre><code class="language-bash">mysql -h 127.0.0.1 -u root gorse &lt; github.sql
</code></pre>
<ul>
<li>Start the master node</li>
</ul>
<pre><code class="language-bash">./gorse-master -c config.toml
</code></pre>
<p><code>-c</code> specify the path of the configuration file.</p>
<ul>
<li>Start the server node and worker node</li>
</ul>
<pre><code class="language-bash">./gorse-server --master-host 127.0.0.1 --master-port 8086 \
    --http-host 127.0.0.1 --http-port 8087
</code></pre>
<p><code>--master-host</code> and <code>--master-port</code> are the RPC host and port of the master node. <code>--http-host</code> and <code>--http-port</code> are the HTTP host and port for RESTful APIs and metrics reporting of this server node.</p>
<pre><code class="language-bash">./gorse-worker --master-host 127.0.0.1 --master-port 8086 \
    --http-host 127.0.0.1 --http-port 8089 -j 4
</code></pre>
<p><code>--master-host</code> and <code>--master-port</code> are the RPC host and port of the master node. <code>--http-host</code> and <code>--http-port</code> are the HTTP host and port for metrics reporting of this worker node. <code>-j</code> is the number of working threads.</p>
<h2 id="play-with-gorse"><a class="header" href="#play-with-gorse">Play with Gorse:</a></h2>
<p>There are HTTP entries provided by Gorse:</p>
<table><thead><tr><th>Entry</th><th>Link</th></tr></thead><tbody>
<tr><td>Master Dashboard</td><td>http://127.0.0.1:8088/</td></tr>
<tr><td>Server RESTful API</td><td>http://127.0.0.1:8087/apidocs</td></tr>
<tr><td>Server Prometheus Metrics</td><td>http://127.0.0.1:8087/metrics</td></tr>
<tr><td>Worker Prometheus Metrics</td><td>http://127.0.0.1:8089/metrics</td></tr>
</tbody></table>
<h3 id="master-dashboard"><a class="header" href="#master-dashboard">Master Dashboard</a></h3>
<p><img src="img/dashboard.jpg" alt="" /></p>
<h3 id="server-restful-api"><a class="header" href="#server-restful-api">Server RESTful API</a></h3>
<p><img src="img/swagger.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommend-using-gorse"><a class="header" href="#recommend-using-gorse">Recommend using Gorse</a></h1>
<p>Each components and concepts of Gorse will be introduced in this section.</p>
<h2 id="users-items-and-feedback"><a class="header" href="#users-items-and-feedback">Users, Items and Feedback</a></h2>
<p>A recommender system is expected to recommend items to users. To learn the peference of each user, feedbacks between users and items are feed to recommender system. In Gorse, there are three types of entities.</p>
<ul>
<li><strong>User:</strong> A user is identified by a string identifier.</li>
</ul>
<pre><code class="language-go">type User struct {
	UserId    string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item is identified by a string identifier. A timestamp is used to record the freshness of this item. The timestamp could be last update time, release time, etc. Labels are used to describe characters of this item, eg., tags of a movie.</li>
</ul>
<pre><code class="language-go">type Item struct {
	ItemId    string
	Timestamp time.Time
	Labels    []string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback is identified a triple: feedback type, user ID and item ID. The type of feedback can be positive (like), negative (dislike) or neutural (read). The timestamp record the time that this feedback happened.</li>
</ul>
<pre><code class="language-go">type Feedback struct {
	FeedbackType string
	UserId       string
	ItemId       string
	Timestamp   time.Time
}
</code></pre>
<p>Types of feedbacks are classified to three categories: </p>
<ol>
<li><code>positive_feedback_types</code> mean a user favors a item. </li>
<li><code>click_feedback_types</code> mean a user favors a recommended item. This item must be recommended by Gorse.</li>
<li><code>read_feedback_type</code> means a user read a item. However, the real feedback this user has in his/her mind is never known.</li>
</ol>
<p>The difference between <code>positive_feedback_types</code> and <code>click_feedback_types</code> is that the item of <code>click_feedback_types</code> must come from recommendations of Gorse. The item of <code>positive_feedback_types</code> could be found by a user through other approaches such as search, direct access, etc. <code>read_feedback_type</code> is a neutral event. Negative feedback can be conduct by {<code>read_feedback_type</code> items} - {<code>positive_feedback_types</code> items}.</p>
<blockquote>
<p>There might be extra field in the defined structure. They are preserved for future usage.</p>
</blockquote>
<h2 id="workflow"><a class="header" href="#workflow">Workflow</a></h2>
<p>The main workflow of Gorse is as follows:</p>
<center><img width=480 src="img/workflow.png"/></center>
<ol>
<li>Feedbacks generated by users are collected to data store.</li>
<li>Archived feedbacks are pulled to train recommender model. There are two type of models (ranking model and CTR model) in Gorse, they are treated as one here.</li>
<li>Offline recommendations are generated in background from all items and cached.</li>
<li>Online recommendations are returned to users in real-time based on cached offline recommendations.</li>
</ol>
<h2 id="data-storage"><a class="header" href="#data-storage">Data Storage</a></h2>
<p>There are two types of storage used in Gorse: data store and cache store.</p>
<h3 id="data-store"><a class="header" href="#data-store">Data Store</a></h3>
<p>The <code>data_store</code> is used to store items, users, feedbacks and measurements. Currently, MySQL and MongoDB are supprted as data store. Other database will be avaiable once its interface is implemented. </p>
<p>Unfortunately, there are two challenges in data storage:</p>
<ol>
<li>
<p>What if a feedback with unknown user or item is inserted? There are two options <code>auto_insert_user</code> and <code>auto_insert_item</code> to control feedback insertion. If new users or items insertion is forbided, a feedback with new user or item will be ignored.</p>
</li>
<li>
<p>How to address stale feedback and items? Some items and its feedbacks are short-lived such as news. <code>positive_feedback_ttl</code> and <code>item_ttl</code> are used to ignore stale feedback and items when pulling dataset from data store.</p>
</li>
</ol>
<h3 id="cache-store"><a class="header" href="#cache-store">Cache Store</a></h3>
<p>The <code>cache_store</code> is used to store offline recommendation and temp variables. Only Redis is supported. Latest items, popular items, similar items and recommended items are cached in Redis. The length of each cached list is <code>cache_size</code>.</p>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Recommended items come from multiple sources through multiple stages. Non-personalized recommendations (popular/latest/similar) are generated by the master node. Offline personalized recommendations are generated by worker nodes while online personalized recommendations are generated by server nodes.</p>
<h3 id="popular-items"><a class="header" href="#popular-items">Popular Items</a></h3>
<p>Items with maximum number of users will are collected. To avoid popular items resist on the top list, <code>popular_window</code> restricts that timestamps of collected items must be after <code>popular_window</code> days ago. There will be no timestamp restriction if <code>popular_window</code> is <code>0</code>.</p>
<h3 id="latest-items"><a class="header" href="#latest-items">Latest Items</a></h3>
<p>Items with latest timestamps are collected. Items won't be added to latest items collection if their timestamp is empty.</p>
<h3 id="similar-items"><a class="header" href="#similar-items">Similar Items</a></h3>
<p>For each item, top n (n equals <code>cache_size</code>) similar items are collected. In current implementation, the similarity between items are the number of common users of two items<sup class="footnote-reference"><a href="#6">1</a></sup>.</p>
<h3 id="offline-recommendation"><a class="header" href="#offline-recommendation">Offline Recommendation</a></h3>
<p>Worker nodes collect top n items from all items and save them to cache. Besides, latest items are added to address the cold-start problem in recommender system. When labels of items exists, the CTR prediction model is enabled, vice versa. The procedure of offline recommendatin is different depend on whether the CTR model is enabled.</p>
<p><strong>If the CTR model is enabled:</strong></p>
<ol>
<li>Collect top <code>cache_size</code> items from unseen items of currrent user using ranking model.</li>
<li>Append <code>explore_latest_num</code> latest items to the collection.</li>
<li>Rerank collected items using the CTR prediction model.</li>
</ol>
<p><strong>If the CTR model is disabled:</strong></p>
<ol>
<li>Collect top <code>cache_size</code> items from unseen items of currrent user using ranking model.</li>
<li>Insert <code>explore_latest_num</code> latest items to random positions in the collection.</li>
</ol>
<p>Offline recommendation cache will be consumed by users and fashion will change. Offline recommendation will be refreshed under one of these two conditions:</p>
<ul>
<li>The timestamp of offline recommendation has been <code>refresh_recommend_period</code> days ago.</li>
<li>New feedbacks have been inserted since the timestamp of offline recommendation.</li>
</ul>
<p>There are 4 ranking models (BPR<sup class="footnote-reference"><a href="#5">2</a></sup>/ALS<sup class="footnote-reference"><a href="#3">3</a></sup>/CCD<sup class="footnote-reference"><a href="#4">4</a></sup>) and 1 CTR model (factorization machines<sup class="footnote-reference"><a href="#2">5</a></sup>) in Gorse. They will be applied automatically by model searcher. In ranking models, items and users are represented as embedding vectors. Since the dot product between two vectors is fast, ranking models are used to find top N items among all items. In CTR models, features from users or items are used in prediction. It's expensive to use CTR models to predict scores of all items.</p>
<h3 id="online-recommendation"><a class="header" href="#online-recommendation">Online Recommendation</a></h3>
<p>The online recommendation in the server node consists of three stages:</p>
<ol>
<li>Load offline recommendation from cache, remove read items.</li>
<li>If the number of offline recommendations is less than required, collect items similar to these items in the user's histrical feedbacks. Read items are removed as well.</li>
<li>If the number of recommendations is still less than required, collect items from <code>fallback_recommend</code> (latest items or popular items). Read items are removed.</li>
</ol>
<h2 id="model-update"><a class="header" href="#model-update">Model Update</a></h2>
<p>There are two kinds of models in Gorse, but the training and hyperparameters optimization procedures are quite the same. </p>
<h3 id="model-training"><a class="header" href="#model-training">Model Training</a></h3>
<p>Model training are done by the master node, as well as model search. The master node pull data from database and fit ranking model and CTR model periodically.</p>
<blockquote>
<ul>
<li>For every <code>fit_jobs</code> minutes:
<ul>
<li>Pull data from database.
<ul>
<li>Train model with hyperparameters found by model search using <code>fit_jobs</code> jobs.</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="model-search"><a class="header" href="#model-search">Model Search</a></h3>
<p>There are many hyperparameters for each recommendation model in Gorse. However, it is hard to configuare these hyperparameters manually even for machine learning experts. To help users get rid of hyperparameters tuning, Gorse integrates random search<sup class="footnote-reference"><a href="#1">6</a></sup> for hyperparameters optimization. The procedure of model search is as following:</p>
<blockquote>
<ul>
<li>For every <code>search_period</code> minutes:
<ul>
<li>Pull data from database.</li>
<li>For every recommender models:
<ul>
<li>For <code>search_trials</code> trials:
<ul>
<li>Sample a hyperparameter combination.</li>
<li>Train model with sampled hyperparameters by <code>search_epoch</code> epoches and <code>search_jobs</code> jobs.</li>
<li>Update best model.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="online-evaluation"><a class="header" href="#online-evaluation">Online Evaluation</a></h2>
<p>The only method to estimate recommendation performance is online evaluation. The metric of online evaluation in Gorse is click-through-rate: <code>click feedback</code> / <code>read feedback</code>.</p>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">1</sup>
<p>Zhang, Zhenghao, et al. &quot;SANS: Setwise Attentional Neural Similarity Method for Few-Shot Recommendation.&quot; DASFAA (3). 2021.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">2</sup>
<p>Rendle, Steffen, et al. &quot;BPR: Bayesian personalized ranking from implicit feedback.&quot; Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence. 2009.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Hu, Yifan, Yehuda Koren, and Chris Volinsky. &quot;Collaborative filtering for implicit feedback datasets.&quot; <em>2008 Eighth IEEE International Conference on Data Mining</em>. Ieee, 2008.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>He, Xiangnan, et al. &quot;Fast matrix factorization for online recommendation with implicit feedback.&quot; Proceedings of the 39th International ACM SIGIR conference on Research and Development in Information Retrieval. 2016.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">5</sup>
<p>Rendle, Steffen. &quot;Factorization machines.&quot; <em>2010 IEEE International Conference on Data Mining</em>. IEEE, 2010. </p>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">6</sup>
<p>Bergstra, James, and Yoshua Bengio. &quot;Random search for hyper-parameter optimization.&quot; Journal of machine learning research 13.2 (2012).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Previous section <em><a href="ch01-02-recommend.html">Recommend using Gorse</a></em> is helpful to understand configurations introduced in this section. These configuration items without default values must be filled. It's highly recommended to create new config file based on <a href="https://github.com/zhenghaoz/gorse/blob/master/config/config.toml.template"><code>config.toml.template</code></a>.</p>
<h2 id="database"><a class="header" href="#database"><code>[database]</code></a></h2>
<p>Configuratios under <code>[database]</code> are used to define behaviors on database and data.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data_store</code></td><td>string</td><td></td><td>Database for data store (supports MySQL/MongoDB)</td></tr>
<tr><td><code>cache_store</code></td><td>string</td><td></td><td>Database for cache store (supports Redis)</td></tr>
<tr><td><code>auto_insert_user</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new users when inserting new feedback</td></tr>
<tr><td><code>auto_insert_item</code></td><td>boolean</td><td><code>true</code></td><td>Automatically insert new items when inserting new feedback</td></tr>
<tr><td><code>cache_size</code></td><td>string</td><td><code>100</code></td><td>Number of cached elements in cache store</td></tr>
<tr><td><code>positive_feedback_types</code></td><td>string</td><td></td><td>Types of positive feedback</td></tr>
<tr><td><code>click_feedback_types</code></td><td>string</td><td></td><td>Types of feedback for click events</td></tr>
<tr><td><code>read_feedback_type</code></td><td>string</td><td></td><td>Type of feedback for read events</td></tr>
<tr><td><code>positive_feedback_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of positive feedback</td></tr>
<tr><td><code>item_ttl</code></td><td>string</td><td><code>0</code></td><td>Time-to-live of items</td></tr>
</tbody></table>
<p>The DSN (Database Source Name) format of the <code>data_store</code> and <code>cache_store</code> is as follows.</p>
<ul>
<li>Redis: <code>redis://hostname:port</code></li>
<li>MySQL: <code>mysql://[username[:password]@][protocol[(hostname:port)]]/database[?config1=value1&amp;...configN=valueN]</code></li>
<li>MongoDB: <code>mongodb://[username:password@]hostname1[:port1][,... hostnameN[:portN]]][/[database][?options]]</code></li>
</ul>
<h2 id="master"><a class="header" href="#master"><code>[master]</code></a></h2>
<p>Configuratios under <code>[master]</code> are used to define behaviors of the master node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td><code>127.0.0.1</code></td><td>Master node listening host for gRPC service (metadata exchange)</td></tr>
<tr><td><code>port</code></td><td>integer</td><td><code>8086</code></td><td>Master node listening port for gRPC service (metadata exchange)</td></tr>
<tr><td><code>http_host</code></td><td>string</td><td><code>127.0.0.1</code></td><td>Master node listening host for HTTP service (dashboard)</td></tr>
<tr><td><code>http_port</code></td><td>integer</td><td><code>8088</code></td><td>Master node listening port for HTTP service (dashboard)</td></tr>
<tr><td><code>fit_jobs</code></td><td>integer</td><td><code>1</code></td><td>Number of working threads for model training</td></tr>
<tr><td><code>search_jobs</code></td><td>integer</td><td><code>1</code></td><td>Number of working threads for model search</td></tr>
<tr><td><code>meta_timeout</code></td><td>integer</td><td><code>60</code></td><td>Metadata timeout in seconds</td></tr>
</tbody></table>
<h2 id="server"><a class="header" href="#server"><code>[server]</code></a></h2>
<p>Configuratios under <code>[server]</code> are used to define behaviors of the server node.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default_n</code></td><td>integer</td><td><code>10</code></td><td>Default number of returned items</td></tr>
<tr><td><code>api_key</code></td><td>string</td><td></td><td>Secret key for RESTful APIs (SSL required)</td></tr>
</tbody></table>
<h2 id="recommend"><a class="header" href="#recommend"><code>[recommend]</code></a></h2>
<p>Configuratios under <code>[recommend]</code> are used to define behaviors of recommendation.</p>
<table><thead><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>popular_window</code></td><td>integer</td><td><code>180</code></td><td>Time window of popular items in days</td></tr>
<tr><td><code>fit_period</code></td><td>integer</td><td><code>60</code></td><td>Period of model trainig in minutes</td></tr>
<tr><td><code>search_period</code></td><td>integer</td><td><code>180</code></td><td>Period of model search in minutes</td></tr>
<tr><td><code>search_epoch</code></td><td>integer</td><td><code>100</code></td><td>Number of training epoches for each model in model search</td></tr>
<tr><td><code>search_trials</code></td><td>integer</td><td><code>10</code></td><td>Number of trials for each model in model search</td></tr>
<tr><td><code>refresh_recommend_period</code></td><td>integer</td><td><code>5</code></td><td>Period to refresh offline recommendation cache in days</td></tr>
<tr><td><code>fallback_recommend</code></td><td>integer</td><td><code>latest</code></td><td>Source of recommendation when personalized recommendation exhausted</td></tr>
<tr><td><code>explore_latest_num</code></td><td>integer</td><td><code>10</code></td><td>Number of latest items add to offline recommendation to address cold-start problem</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitrec-the-live-demo"><a class="header" href="#gitrec-the-live-demo">GitRec, The Live Demo</a></h1>
<p><a href="https://gitrec.gorse.io/">GitRec</a>, the live demo, is developed to demonstrate the usage of Gorse recommender system engine. A user logins in via GitHub OAuth, then repositories starred by this user before are imported to Gorse. Gorse recommends repositories to this user based on starred repositories. When this user saw a recommended repository, he or she can press ❤️ to tell GitRec that he or she like this recommendationn and press ⏯️ to skip current recommendationn.</p>
<p><img src="img/gitrec.jpg" alt="" /></p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<center><img width="500" src="img/gitrec-architecture.png"/></center>
<ul>
<li><strong>Import new repositories</strong>: The trending crawler crawls trending repositories and insert them into Gorse as new items. Since there are huge nuumber of repositories in GitHub, it's impossible add all of them into GitRec. So, only trending repositories are imported.</li>
<li><strong>Import user starred repositories</strong>: The user starred crawler crawls user starred repositories and insert them into Gorse as new fewdback typed <code>star</code> when a new user signed in.</li>
<li><strong>Recommendation and feedbacks</strong>: GitRec web service pulls recommendations from Gorse and show to users. When a user press ❤️, a feedback typed <code>like</code> will be inserted to Gorse. When ⏯️ pressed, a feedback typed <code>view</code> will be inserted to Gorse.</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>In GitRec, there are three types of feedbacks: <code>read</code>, <code>star</code> and <code>like</code>. <code>read</code> is the feedback type for read events (a user skip a recommended repository). <code>like</code> is the feedback type for user press ❤️. <code>star</code> is the feedback type for user starred repositories. Since <code>star</code> events doesn't happen in GitRec, it won't be added to <code>click_feedback_types</code>. </p>
<pre><code class="language-toml"># feedback type for positive event
positive_feedback_types = [&quot;star&quot;,&quot;like&quot;]

# feedback type for click event
click_feedback_types = [&quot;like&quot;]

# feedback type for read event
read_feedback_type = &quot;read&quot;
</code></pre>
<p>Other settings are the same as <a href="https://github.com/zhenghaoz/gorse/blob/master/docker/config.toml">docker/config.toml</a>.</p>
<h2 id="implemenetation"><a class="header" href="#implemenetation">Implemenetation</a></h2>
<p>This project consists of frontend, backend and crawlers. In this section, only these codes interact with Gorse are introduced. Other codes are avaliable in the <a href="https://github.com/zhenghaoz/gitrec">GitRec repository</a>.</p>
<ol>
<li>First thing is to wrap Gorse API as a python module. It sends HTTP requests and handle responses using <code>requests</code>.</li>
</ol>
<pre><code class="language-python">from collections import namedtuple
from datetime import datetime
from typing import List

import requests

Success = namedtuple(&quot;Success&quot;, [&quot;RowAffected&quot;])


class GorseException(BaseException):
    def __init__(self, status_code: int, message: str):
        self.status_code = status_code
        self.message = message


class Gorse:
    def __init__(self, entry_point):
        self.entry_point = entry_point

    def insert_feedback(
        self, feedback_type: str, user_id: str, item_id: str
    ) -&gt; Success:
        r = requests.post(
            self.entry_point + &quot;/api/feedback&quot;,
            json=[
                {
                    &quot;FeedbackType&quot;: feedback_type,
                    &quot;UserId&quot;: user_id,
                    &quot;ItemId&quot;: item_id,
                    &quot;Timestamp&quot;: datetime.now().isoformat(),
                }
            ],
        )
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def get_recommend(self, user_id: str, n: int = 1) -&gt; List[str]:
        r = requests.get(self.entry_point + &quot;/api/recommend/%s?n=%d&quot; % (user_id, n))
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_feedbacks(self, feedbacks) -&gt; Success:
        r = requests.post(self.entry_point + &quot;/api/feedback&quot;, json=feedbacks)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)

    def insert_item(self, item) -&gt; List[str]:
        r = requests.post(self.entry_point + &quot;/api/item&quot;, json=item)
        if r.status_code == 200:
            return r.json()
        raise GorseException(r.status_code, r.text)
</code></pre>
<ol start="2">
<li>In the code of trending crawler, insert trending repositories as new items.</li>
</ol>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    trending_repos = get_trending()
    for trending_repo in trending_repos:
        gorse_client.insert_item(get_repo_info(trending_repo))
</code></pre>
<ol start="3">
<li>In the code of starred repositories crawler, insert user starred repositories as <code>star</code> feedbacks.</li>
</ol>
<pre><code class="language-python">@app.task
def pull(token: str):
    g = GraphQLGitHub(token)
    stars = g.get_viewer_starred()
    gorse_client.insert_feedbacks(stars)
</code></pre>
<ol start="4">
<li>In the code of web service backend, pull recommendations from Gorse, insert <code>like</code> and <code>read</code> into Gorse.</li>
</ol>
<pre><code class="language-python">@app.route(&quot;/api/repo&quot;)
def get_repo():
    repo_id = gorse_client.get_recommend(session[&quot;user_id&quot;])[0]
    full_name = repo_id.replace(&quot;:&quot;, &quot;/&quot;)
    github_client = Github(github.token[&quot;access_token&quot;])
    repo = github_client.get_repo(full_name)
    # ...


@app.route(&quot;/api/like/&lt;repo_name&gt;&quot;)
def like_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;like&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)


@app.route(&quot;/api/read/&lt;repo_name&gt;&quot;)
def read_repo(repo_name: str):
    try:
        return gorse_client.insert_feedback(&quot;read&quot;, session[&quot;user_id&quot;], repo_name)
    except gorse.GorseException as e:
        return Response(e.message, status=e.status_code)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-build-recommender"><a class="header" href="#chapter-2-build-recommender">Chapter 2: Build Recommender</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback-collection"><a class="header" href="#feedback-collection">Feedback Collection</a></h1>
<p>In a recommender system, data is the foundation of all recommendation results, and this section will briefly introduce how to collect user data for Gorse recommender system. The recommender system relies on the feedback between users and items as training data, and the quality of training data determines the quality of recommendations.</p>
<h2 id="users-items-and-feedback-1"><a class="header" href="#users-items-and-feedback-1">Users, Items and Feedback</a></h2>
<p>Recommender system is complex, but to maximize reusability, Gorse has abstracted the data used in a recommender system as a collection of three entities: users, items, and feedback.</p>
<ul>
<li><strong>User:</strong> A user entity consists of a user ID and labels describing the user. The user labels can be empty, but these labels helps to improve the recommendation accuracy of the recommender system.</li>
</ul>
<pre><code class="language-go">type User struct {
    UserId    string
    Labels    []string
}
</code></pre>
<ul>
<li><strong>Item:</strong> A item entity consists of an item ID, an item timestamp and labels describing the item. The timestamp and labels can be empty, and the similarly based on labels information helps to improve the recommendation accuracy of the recommender system, while the timestamp is used to estimate the freshness of the item.</li>
</ul>
<pre><code class="language-go">type Item struct {
    ItemId    string
    Timestamp time.Time
    Labels    []string
}
</code></pre>
<ul>
<li><strong>Feedback:</strong> A feedback entity consists of user ID, item ID, feedback type and feedback timestamp, where the triad of user ID, item ID and feedback type is required to be unique in the database.</li>
</ul>
<p>Feedback represent events happened between users and items, which can be positive or negative. For example, sharing and liking are the user's positive feedback to a item. If the user does not have further positive feedback after reading, the user's feedback to the item is considered negative. If the user views the item, a read feedback will be recorded. Then, if the user gives positive feedback to the item, the read feedback will be overwritten by the positive feedback. Conversely, if the user does not give positive feedback, then the read feedback is considered as negative feedback.</p>
<pre><code class="language-go">type Feedback struct {
    FeedbackType string
    UserId       string
    ItemId       string
    Timestamp    time.Time
}
</code></pre>
<p>Gorse's server node provides RESTful APIs for inserting users, items and feedback, as well as getting recommendation for users. Please refer to the RESTful API documentation for a detailed description.</p>
<table><thead><tr><th>METHOD</th><th>URL</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>POST</td><td>/api/item</td><td>Insert item.</td></tr>
<tr><td>POST</td><td>/api/user</td><td>Insert user.</td></tr>
<tr><td>POST</td><td>/api/feedback</td><td>Insert feedback if the feedback not exist.</td></tr>
<tr><td>PUT</td><td>/api/feedback</td><td>Insert feedback, and overwrites existed feedback.</td></tr>
</tbody></table>
<h2 id="define-positive-feedback-and-read-feedback"><a class="header" href="#define-positive-feedback-and-read-feedback">Define Positive Feedback and Read Feedback</a></h2>
<p>Before inserting feedback to the Gorse recommender system, it is necessary to define which of the user's behaviors are positive feedback and which are read feedback. Read feedback is relatively easy to define, as it can be recorded as read feedback when a user has seen the recommended item. However, the definition of positive feedback depends more on the specific scenario. For TikTok, users can be considered as positive feedback if they “like” or “share” the current video; for YouTube, users can be considered as positive feedback if they watch the video to a certain proportion of completion, “like“ the video, or &quot;share&quot; the video. To summarize, positive feedback and read feedback are defined by the following rules.</p>
<ul>
<li><strong>Read Feedback:</strong> The user sees the item.</li>
<li><strong>Positive feedback:</strong> The user action that is expected to do by the service provider.</li>
</ul>
<p>For example, if Gabe Newell wants to build a recommender system for Steam based on Gorse, clicking into the game introduction page could be treated as read feedback (the game list page has too little information to determine that the user has read it), and then actions such as adding a wish list and adding a shopping cart are treated as positive feedback. Finally, set them in the configuration file as follows.</p>
<pre><code class="language-toml"># Add to wishlist or cart
positive_feedback_types = [&quot;wish_list&quot;, &quot;cart&quot;]

# Read the game introduction page
read_feedback_types = [&quot;read&quot;]
</code></pre>
<h2 id="insert-positive-feedback"><a class="header" href="#insert-positive-feedback">Insert Positive Feedback</a></h2>
<p>For positive feedback, it can be inserted when the user performs the action, where the timestamp is the current timestamp.</p>
<pre><code class="language-bash">curl -X POST &quot;http://127.0.0.1:8088/api/feedback&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;Content-Type: application/json&quot; \
    -d '[ { &quot;FeedbackType&quot;: &quot;read&quot;, &quot;ItemId&quot;: &quot;10086&quot;, &quot;Timestamp&quot;: &quot;2021-10-24T06:42:20.207Z&quot;, &quot;UserId&quot;: &quot;jack&quot; }]'
</code></pre>
<h2 id="insert-read-feedback"><a class="header" href="#insert-read-feedback">Insert Read Feedback</a></h2>
<p>For read feedback, the timestamp can be used to set the timeout of the recommendation results, in addition to recording the read time.</p>
<h3 id="proactive-insertion"><a class="header" href="#proactive-insertion">Proactive Insertion</a></h3>
<p>Positive feedback can be inserted into the recommender system when the user takes the action, while read feedback requires the application to detect the user's &quot;read&quot; behavior. The methods for displaying recommendations vary by application, but can be generally grouped into two categories.</p>
<ul>
<li><strong>Full screen mode:</strong> The most typical application is TikTok, where the user is considered &quot;read&quot; when the full screen content is shown to them. That is, the application can write a &quot;read&quot; feedback to the recommender system when the recommended content is shown to the user, and the read content will no longer be shown to the user.</li>
</ul>
<img src="/img/ch2/tiktok.jpg" width="300">
<img src="/img/ch2/youtube.jpg" width="300">
<ul>
<li><strong>List mode:</strong> The most typical application is YouTube, where the user is not considered &quot;read&quot; after looking at multiple videos in the list. When there are more than one videos, the user's attention is not able to browse the whole list. Moreover, if the read content is quickly discarded in the list mode, the recommended content is consumed too fast. Therefore, the best solution is to write a read feedback with a future timestamp to the recommender system when the item is presented to the user in the stream, and the read feedback will take effect when the time has reached the timestamp, and the read content will no longer be presented to the user.</li>
</ul>
<h3 id="automatic-insertion"><a class="header" href="#automatic-insertion">Automatic Insertion</a></h3>
<p>Proactively inserting read feedback to the recommender system requires the application to be able to accurately capture user browsing behavior. This task is easier for mobile applications, but more difficult for web applications. To address this problem, Gorse's API for getting recommendation results provides two parameters: <code>write−back−type</code> and <code>write−back−delay</code>.</p>
<ul>
<li><strong>In full screen mode:</strong> Get a recommendation and write a &quot;read&quot; feedback, the recommendation will not appear again afterwards.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;n=1&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<ul>
<li><strong>In list mode:</strong> Get 10 recommendations and write &quot;read&quot; feedback with timestamps of 10 minutes later. The 10 recommendations will not be discarded until after 10 minutes.</li>
</ul>
<pre><code class="language-bash">curl -X GET &quot;http://172.18.0.3:8087/api/recommend/zhenghaoz?write-back-type=read&amp;write-back-delay=10&amp;n=10&quot; \
    -H &quot;accept: application/json&quot; \
    -H &quot;X-API-Key: 19260817&quot;
</code></pre>
<p>The <code>write−back−type</code> and <code>write−back−delay</code> parameters of the recommendation API provide a convenient way to insert read feedback, but of course if you want the read feedback to be more accurate, it should be written to the recommender system by the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recommendation-strategy"><a class="header" href="#recommendation-strategy">Recommendation Strategy</a></h1>
<p>Gorse recommender system implements different types of recommenders, both non-personalized and personalized. In fact, no single recommender is a panacea, and only a combination of them can be used to achieve the best recommendation results.</p>
<h2 id="recommenders"><a class="header" href="#recommenders">Recommenders</a></h2>
<p>First, this section introduces the various types of recommenders in Gorse, each of which has its pros and cons.</p>
<h3 id="latest-recommender"><a class="header" href="#latest-recommender">Latest Recommender</a></h3>
<p>Latest recommender shows the latest items to users according to timestamps, which allows new item to be exposed to users in time. However, the downside of latest recommender is that it does not consider the quality (or popularity) of items. To enable latest recommender in Gorse, you need to set timestamp information for the items. Without timestamps, Gorse will not generate a list of latest items.</p>
<pre><code class="language-go">type Item struct {
    ItemId    string
    Timestamp time.Time // The timestamp is required.
    Labels    []string
    Comment   string
}
</code></pre>
<h3 id="popular-recommender"><a class="header" href="#popular-recommender">Popular Recommender</a></h3>
<p>Popular recommender shows the recent popular items to users, most typically Twitter trending. In Gorse, the <code>popular_window</code> in the configuration file corresponds to the window of popular items, the following example is to recommend popular items within one year (a bit too long).</p>
<pre><code class="language-toml">popular_window = 365
</code></pre>
<p>Popular recommender is obviously not suitable to be used alone, otherwise it would result in new items not being exposed. Many sites display content with a combination of popular and latest recommendations, such as calculating a score based on popularity and freshness, and finally sorting by score.</p>
<h3 id="item-based-similarity-recommender"><a class="header" href="#item-based-similarity-recommender">Item-based Similarity Recommender</a></h3>
<p>In some scenarios, users like specific types of items, for example, gamers like to solve puzzles, or users of a video platform like to watch dancing girls. Based on the user's history and the similarity between items, item-based similarity recommender recommends items to users. The critical step of item-based similarity recommender is to calculate the similarity between items.</p>
<p>Gorse calculates item similarity in three modes, which can be set in the configuration file.</p>
<ul>
<li><strong>Similarity:</strong> Calculates similarity based on label overlap between items.</li>
<li><strong>Related:</strong> Calculates similarity based on user overlap between items.</li>
<li><strong>Automatic:</strong> Prefer to use labels to calculate similarity, if there are no labels then use users to calculate similarity.</li>
</ul>
<pre><code class="language-toml"># The type of neighbors for items. There are three types:
#   similar: Neighbors are found by number of common labels.
#   related: Neighbors are found by number of common users.
#   auto: If a item have labels, neighbors are found by number of common labels.
#         If this item have no labels, neighbors are found by number of common users.
# The default values is &quot;auto&quot;.
item_neighbor_type = &quot;similar&quot;
</code></pre>
<p>It is recommended to choose <code>similar</code> or <code>auto</code> because item-based similarity recommender using <code>related</code> recommends similarly to collaborative filtering recommenders. The advantage of item-based similarity (labels-based) recommender is that it can quickly recommend a new item to users who are interested in such items based on the labels. Of course, this recommender requires accurate labels for the items, and invalid labels are counterproductive.</p>
<h3 id="user-based-similarity-recommender"><a class="header" href="#user-based-similarity-recommender">User-based Similarity Recommender</a></h3>
<p>There are also common preferences among similar users. For example, students majoring in computer science usually buy books about computer science, and elders like to buy health care products.</p>
<p>Gorse calculates the similarity between users in three modes, which can be set in the configuration file.</p>
<ul>
<li><strong>Similarity:</strong> Calculates similarity based on label overlap between users.</li>
<li><strong>Related:</strong> Calculates similarity based on historical item overlap between users.</li>
<li><strong>Automatic:</strong> Prioritizes the use of user labels, if there are no labels then the similarity is calculated using historical items.</li>
</ul>
<pre><code class="language-toml"># The type of neighbors for users. There are three types:
#   similar: Neighbors are found by number of common labels.
#   related: Neighbors are found by number of common liked items.
#   auto: If a user have labels, neighbors are found by number of common labels.
#         If this user have no labels, neighbors are found by number of common liked items.
# The default values is &quot;auto&quot;.
user_neighbor_type = &quot;similar&quot;
</code></pre>
<p>It is recommended to choose <code>similar</code> or <code>auto</code> because user-based Similarity Recommender using <code>related</code> is similar to collaborative filtering recommender. The recommender is friendly to new users. With user labels, recommendations can be generated based on similar users' preferences even if the user does not have any history.</p>
<h3 id="collaborative-filtering-recommender"><a class="header" href="#collaborative-filtering-recommender">Collaborative Filtering Recommender</a></h3>
<p>Recommenders based on similar items and similar users require that the recommended items need to be linked with similar users or historical items of the recommended user, which limits the scope of recommended items searching. The collaborative filtering recommender in Gorse uses matrix factorization to recommend items. The training algorithm maps users and items to embedding vectors in a high-dimensional space, and the user's preference for an item is the dot product of the user embedding vector and the item embedding vector. However, the disadvantage of collaborative filtering recommender is that it cannot utilize the label information of users and items, and it cannot handle new users and new items.</p>
<h3 id="click-through-rate-prediction"><a class="header" href="#click-through-rate-prediction">Click-through Rate Prediction</a></h3>
<p>Is there a recommender that combines advantages of similarity recommender and collaborative filtering recommender? Then it is the click-through rate prediction model. The click-through rate prediction model in Gorse is a factorization machine that generates embedding vectors for each user label and item label in addition to embedding vectors for each user and item. Although the factorization machine model is effective, it is not generally used as a recommender for collecting recommended items over all items. Compared with collaborative filtering recommender and similarity recommender, its computational complexity is large. Gorse's click-through prediction model is used to fuse and rank the results of the above recommenders.</p>
<p>The original meaning of &quot;click-through rate prediction&quot; is to predict the probability that users will click on the recommended content or ads, but it should be noted that the click-through rate prediction in Gorse refers more to the probability that users will give positive feedback to the recommended results. For example, suppose we set in Gorse that positive feedback means the user has watched 50% of the video, then the &quot;click-through rate&quot; is the probability that the user has watched more than 50% of the video.</p>
<h2 id="recommendation-strategy-1"><a class="header" href="#recommendation-strategy-1">Recommendation Strategy</a></h2>
<p>Individual recommenders cannot perform the recommendation task well, and multiple recommenders need to be combined. Gorse provides a workflow for generating recommendation results, under which we can draft recommendation strategies that are suitable for specific scenarios. The recommendation process consists of two main components: offline recommendation and online recommendation. The offline recommendation collects recommendations for each user from the full set of items and caches them in Redis. The online recommendation pulls the cached recommendation results, then removes the read content from the recommendation results, and if the cached recommendation results are exhausted, then the recommendation content is generated in real time using the fallback recommenders.</p>
<h3 id="offline-strategy"><a class="header" href="#offline-strategy">Offline Strategy</a></h3>
<p>Offline recommendation consists of three phases.</p>
<ul>
<li><strong>Matching:</strong> Use different full-set recommenders to collect recommended items from all items. There are five types of full-set recommenders: popular recommender, latest recommender, item-based similarity recommender, user based similarity recommender and collaborative filtering recommender, which can be set on or off in the configuration file.</li>
<li><strong>Ranking:</strong> Use the factorization machine model to rank the items collected by the matching phase, currently you can also turn off the click-through rate prediction in the configuration and use random merge.</li>
<li><strong>Exploration:</strong> Recommend content based on user history can be a good idea for users, but it also limits the possibility of users seeing more diverse content. It is also a kind of &quot;exploration and exploitation&quot; problem, where exploitation refers to recommending content based on users' historical behavior, while exploration refers to exposing users to more content beyond their awareness. One of the easiest ways to expose users to content beyond the information cocoon is to insert random items into the recommendation list, and Gorse can be configured to randomly insert the newest or recent popular items into the recommendation list, with their proportion set in the configuration file.</li>
</ul>
<pre><code class="language-toml"># Enable latest recommendation during offline recommendation. The default values is false.
enable_latest_recommend = true
# Enable popular recommendation during offline recommendation. The default values is false.
enable_popular_recommend = false
# Enable user-based similarity recommendation during offline recommendation. The default values is false.
enable_user_based_recommend = true
# Enable item-based similarity recommendation during offline recommendation. The default values is false.
enable_item_based_recommend = false
# Enable collaborative filtering recommendation during offline recommendation. The default values is true.
enable_collaborative_recommend = true
# Enable click-though rate prediction during offline recommendation. Otherwise, results from multi-way recommendation
# would be merged randomly. The default values is true.
enable_click_through_prediction = true
# The explore recommendation method is used to inject popular items or latest items into recommended result:
#   popular: Recommend popular items to cold-start users.
#   latest: Recommend latest items to cold-start users.
# Recommenders are used in order. The default values is { popular = 0.0, latest = 0.0 }.
explore_recommend = { popular = 0.1, latest = 0.2 }
</code></pre>
<p>Perhaps the introduction of various recommenders is not intuitive enough, you can actually preview the recommendation results in the dashboard. The popular items and the latest items can be seen on the landing page of dashboard.</p>
<p><img src="img/ch2/latest-and-popular.png" alt="" /></p>
<p>The results of offline recommendation, item-based similarity recommendation, user-based similarity recommendation and collaborative filtering recommendation can be viewed on the user page by clicking <em>Insight</em>:</p>
<ul>
<li>Click <em>Users</em> in the navigation bar</li>
<li>Click <em>Insight</em> in the user row</li>
</ul>
<p>You can choose to show offline recommendation results, similarity item recommendation, similar user recommendation and collaborative filtering recommendation results from the drop-down menu on the right side</p>
<p><img src="img/ch2/users.png" alt="" /></p>
<p><img src="img/ch2/user-insight.png" alt="" /></p>
<p>Since Gorse does not yet offer A/B testing, the preview is needed to sensitively draft a recommendation strategy.</p>
<h3 id="online-strategy"><a class="header" href="#online-strategy">Online Strategy</a></h3>
<p>Online recommendations have two tasks.</p>
<ul>
<li><strong>Remove reads:</strong> The read items in the recommendation result cache need to be removed.</li>
<li><strong>Fallback recommendation:</strong> There might be a situation that the cached recommendation results are drain out but new offline recommendations haven't been generated, then the fallback recommenders are needed to generate the recommendation content in real time. The fallback recommenders can be configured in the configuration file with priority from head to tail, and if the front recommender is no longer able to generate recommendation, then continue to try the backward recommender.</li>
</ul>
<pre><code class="language-toml"># The fallback recommendation method for cold-start users:
#   item_based: Recommend similar items to cold-start users.
#   popular: Recommend popular items to cold-start users.
#   latest: Recommend latest items to cold-start users.
# The default values is [&quot;latest&quot;].
fallback_recommend = [&quot;item_based&quot;, &quot;latest&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-monitoring"><a class="header" href="#chapter-3-monitoring">Chapter 3: Monitoring</a></h1>
<p>For an online system in production, &quot;observability&quot; is important. Real-time monitoring of an online system can identify flaws or performance issues before they affect users on a large scale. This chapter will introduce how to monitor the Gorse recommender system for logs and metrics, with the logs capturing abnormal events and the metrics monitoring observing the performance of the system. This chapter will only introduce some key configuration, for a complete configuration sample please refer to the official demo project <a href="https://github.com/zhenghaoz/gitrec">GitRec</a>.</p>
<p>The overview architecture of monitoring infrastructure is as follows:</p>
<ul>
<li>Gorse nodes write logs to log files.</li>
<li><strong>Promtail</strong> reads logs from file and push to <strong>Loki</strong>.</li>
<li><strong>Prometheus</strong> scrapes metrics from Gorse nodes.</li>
<li><strong>Grafana</strong> visualizes logs from <strong>Loki</strong> and metrics from <strong>Prometheus</strong> in dashboards.</li>
</ul>
<img src="img/ch3/monitoring.png" width="600">
<div style="break-before: page; page-break-before: always;"></div><h1 id="log-monitoring"><a class="header" href="#log-monitoring">Log Monitoring</a></h1>
<p>The mainstream log monitoring solutions are ELK and Loki. Loki is chosen in this section because it is more lightweight compared to ELK. The log collection and monitoring process is as follows.</p>
<ul>
<li>Gorse nodes writes the logs to a file.</li>
<li>Promtail reads the logs from the file and pushes them to Loki.</li>
<li>Grafana reads the logs from Loki for visualization.</li>
</ul>
<p>First, you need to set each node to write logs to a file in <code>docker-compose.yml</code>, as well as add Promtail, Loki and Grafana.</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  worker:
    image: zhenghaoz/gorse-worker
    restart: unless-stopped
    ports:
      - 8089:8089
    command: &gt;
      --master-host master --master-port 8086 --http-host 0.0.0.0 --http-port 8089
      --log-path /var/log/gorse/worker.log --cache-path /var/lib/gorse/worker_cache.data
    volumes:
      - ./var/log/gorse:/var/log/gorse
      - ./var/lib/gorse:/var/lib/gorse

  server:
    image: zhenghaoz/gorse-server
    restart: unless-stopped
    ports:
      - 8087:8087
    command: &gt;
      --master-host master --master-port 8086 --http-host 0.0.0.0 --http-port 8087
      --log-path /var/log/gorse/server.log --cache-path /var/lib/gorse/server_cache.data
    volumes:
      - ./var/log/gorse:/var/log/gorse
      - ./var/lib/gorse:/var/lib/gorse

  master:
    image: zhenghaoz/gorse-master
    restart: unless-stopped
    ports:
      - 8086:8086
      - 8088:8088
    command: -c /etc/gorse/config.toml --log-path /var/log/gorse/master.log --cache-path /var/lib/gorse/master_cache.data
    volumes:
      - ./etc/gorse/config.toml:/etc/gorse/config.toml
      - ./var/log/gorse:/var/log/gorse
      - ./var/lib/gorse:/var/lib/gorse

  grafana:
    image: grafana/grafana
    restart: unless-stopped
    ports:
      - 3000:3000
    volumes:
      - grafana-storage:/var/lib/grafana

  loki:
    image: grafana/loki
    restart: unless-stopped
    command: -config.file=/etc/loki/local-config.yaml
    ports:
      - 3100:3100
    volumes:
      - ./etc/loki/local-config.yaml:/etc/loki/local-config.yaml

  promtail:
    image: grafana/promtail
    restart: unless-stopped
    command: -config.file=/etc/promtail/config.yml
    ports:
      - 9080:9080
    volumes:
      - ./var/log/gorse:/var/log/gorse
      - ./etc/promtail/config.yml:/etc/promtail/config.yml

# ...

volumes:
  grafana-storage:
</code></pre>
<p>Loki's configuration file <code>local-config.yaml</code> is as follows.</p>
<pre><code class="language-yaml">auth_enabled: false

server:
  http_listen_port: 3100

ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
    final_sleep: 0s
  chunk_idle_period: 5m
  chunk_retain_period: 30s

schema_config:
  configs:
    - from: 2020-05-15
      store: boltdb
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 168h

storage_config:
  boltdb:
    directory: /tmp/loki/index

  filesystem:
    directory: /tmp/loki/chunks

limits_config:
  enforce_metric_name: false
  reject_old_samples: true
  reject_old_samples_max_age: 168h
</code></pre>
<p>The configuration file for Promtail is as follows.</p>
<pre><code class="language-yaml">server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /var/log/positions.yaml # This location needs to be writeable by Promtail.

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: system
    static_configs:
    - targets:
        - localhost
      labels:
        job: master
        __path__: /var/log/gorse/master.log
    - targets:
        - localhost
      labels:
        job: worker
        __path__: /var/log/gorse/worker.log
    - targets:
        - localhost
      labels:
        job: server
        __path__: /var/log/gorse/server.log
    pipeline_stages:
    - json:
        expressions:
          level: level
    - labels:
        level:
</code></pre>
<p>After deploying <code>docker-compose.yml</code>, login to Grafana and add Loki as a data source:</p>
<img src="img/ch3/loki.png" width="500">
<p>Finally, import the logs dashboard provided in the demo project GitRec to monitor warnings, errors, and fatal logs in the recommender system in real time.</p>
<img src="img/ch3/dashboard-logs-json.png" width="500">
<p>The logs dashboard filters warning, error, and fatal logs.</p>
<ul>
<li><strong>Warning:</strong> Events affect the outcome of the recommender system, but the system has a strategy to deal with them.</li>
<li><strong>Error:</strong> Events affect the function of the system, but the system is still able to continue.</li>
<li><strong>Fatal:</strong> Events prevent the system from continuing to run.</li>
</ul>
<p>Log entries such as database temporarily connection lost, network temporarily timeout, etc. are expected. If an error log is generated that is not expected, welcome to paste it on <a href="https://github.com/zhenghaoz/gorse/issues">GitHub Issues</a>.</p>
<p><img src="/img/ch3/dashboard-logs-preview.jpeg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-monitoring"><a class="header" href="#metrics-monitoring">Metrics Monitoring</a></h1>
<p>Gorse nodes exports Prometheus metrics, and Prometheus can scrape real-time metrics via HTTP from each node. The default HTTP port for worker nodes is <code>8089</code>, the default HTTP port for server nodes is <code>8087</code>, and the default HTTP port for master nodes is <code>8088</code>. The HTTP port for worker and server nodes can be set via the command line option <code>--http-port</code>.</p>
<p>The Prometheus configuration file for scraping Gorse metrics is as follows.</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name:       'gorse'
    scrape_interval: 10s
    static_configs:
      - targets: ['worker:8089', 'server:8087', 'master:8088']
</code></pre>
<p><code>scrape_interval</code> is the scrape frequency and <code>targets</code> is the address to scrape the metrics. Since the above configuration file is used for Docker Compose deployments, the hostname is used instead of the IP address. Next, add an instance of Prometheus to <code>docker-compose.yml</code>, mount the above configuration file to the default configuration file path <code>/etc/prometheus/prometheus.yml</code>.</p>
<pre><code class="language-yaml">version: &quot;3&quot;
services:

  prometheus:
    image: prom/prometheus
    restart: unless-stopped
    ports:
      - 9090:9090
    volumes:
      - ./etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
</code></pre>
<p>After Prometheus started, add Prometheus as a data source in Grafana.</p>
<img src="img/ch3/prometheus.png" width="500">
<p>Finally, import dashboards provided in the demo project GitRec to monitor the count and latency of each service call on the database, cache, worker node, server node, and master node in real time.</p>
<img src="img/ch3/dashboard-json.png" width="500">
<p>The left side of the dashboard shows the count of calls per ten minutes, while the right side shows the call latency within 99%.</p>
<p><img src="img/ch3/dashboard-cache.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>These frequent asked questions are collected from issues, emails and chats. Feel free to ask more questions via <a href="https://github.com/zhenghaoz/gorse/issues">issue</a>, <a href="support@gorse.io">email</a>, <a href="https://discord.com/channels/830635934210588743/">Discord</a> (for English) or <a href="https://qm.qq.com/cgi-bin/qm/qr?k=lOERnxfAM2U2rj4C9Htv9T68SLIXg6uk&amp;jump_from=webapi">QQ</a> (for Chinese).</p>
<h2 id="technical-questions"><a class="header" href="#technical-questions">Technical Questions</a></h2>
<h3 id="1-how-to-address-the-cold-start-problem"><a class="header" href="#1-how-to-address-the-cold-start-problem">1. How to address the cold-start problem?</a></h3>
<p>Use <code>explore_latest_num</code> to inject latest items into recommendation. Also, item labels are helpful to rank new items in recommendation. For example:</p>
<pre><code class="language-toml">explore_latest_num = 10
</code></pre>
<p>It means 10 latest items are inserted to recommended items list.</p>
<h3 id="2-how-to-keep-track-of-items-recommended-to-each-user"><a class="header" href="#2-how-to-keep-track-of-items-recommended-to-each-user">2. How to keep track of items recommended to each user?</a></h3>
<p>There are two options:</p>
<ol>
<li>Insert a read type feedback to Gorse when a item is showed to a user. This is the way the official demo <a href="https://github.com/zhenghaoz/gitrec">zhenghaoz/gitrec</a> tracks user seen recommendations.</li>
<li>Use <code>write-back</code> parameter to write back recommendations as read feedbacks to Gorse, eg:</li>
</ol>
<pre><code class="language-bash">curl -i -H &quot;Accept: application/json&quot; -X GET http://127.0.0.1:8088//api/recommend/0?write-back=read
</code></pre>
<p>The 1st option is more accurate since it is done by front end but the 2rd option is more convenient.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
